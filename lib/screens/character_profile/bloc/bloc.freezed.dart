// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$CharacterProfileEventTearOff {
  const _$CharacterProfileEventTearOff();

// ignore: unused_element
  _CharacterProfileInitialEvent initial() {
    return const _CharacterProfileInitialEvent();
  }
}

/// @nodoc
// ignore: unused_element
const $CharacterProfileEvent = _$CharacterProfileEventTearOff();

/// @nodoc
mixin _$CharacterProfileEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_CharacterProfileInitialEvent value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_CharacterProfileInitialEvent value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CharacterProfileEventCopyWith<$Res> {
  factory $CharacterProfileEventCopyWith(CharacterProfileEvent value,
          $Res Function(CharacterProfileEvent) then) =
      _$CharacterProfileEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$CharacterProfileEventCopyWithImpl<$Res>
    implements $CharacterProfileEventCopyWith<$Res> {
  _$CharacterProfileEventCopyWithImpl(this._value, this._then);

  final CharacterProfileEvent _value;
  // ignore: unused_field
  final $Res Function(CharacterProfileEvent) _then;
}

/// @nodoc
abstract class _$CharacterProfileInitialEventCopyWith<$Res> {
  factory _$CharacterProfileInitialEventCopyWith(
          _CharacterProfileInitialEvent value,
          $Res Function(_CharacterProfileInitialEvent) then) =
      __$CharacterProfileInitialEventCopyWithImpl<$Res>;
}

/// @nodoc
class __$CharacterProfileInitialEventCopyWithImpl<$Res>
    extends _$CharacterProfileEventCopyWithImpl<$Res>
    implements _$CharacterProfileInitialEventCopyWith<$Res> {
  __$CharacterProfileInitialEventCopyWithImpl(
      _CharacterProfileInitialEvent _value,
      $Res Function(_CharacterProfileInitialEvent) _then)
      : super(_value, (v) => _then(v as _CharacterProfileInitialEvent));

  @override
  _CharacterProfileInitialEvent get _value =>
      super._value as _CharacterProfileInitialEvent;
}

/// @nodoc
class _$_CharacterProfileInitialEvent
    with DiagnosticableTreeMixin
    implements _CharacterProfileInitialEvent {
  const _$_CharacterProfileInitialEvent();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterProfileEvent.initial()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterProfileEvent.initial'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CharacterProfileInitialEvent);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult initial(),
  }) {
    assert(initial != null);
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult initial(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult initial(_CharacterProfileInitialEvent value),
  }) {
    assert(initial != null);
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult initial(_CharacterProfileInitialEvent value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _CharacterProfileInitialEvent implements CharacterProfileEvent {
  const factory _CharacterProfileInitialEvent() =
      _$_CharacterProfileInitialEvent;
}

/// @nodoc
class _$CharacterProfileStateTearOff {
  const _$CharacterProfileStateTearOff();

// ignore: unused_element
  _CharacterProfileLoadingState loading() {
    return const _CharacterProfileLoadingState();
  }

// ignore: unused_element
  _CharacterProfileDataState data(
      {@required CharacterProfileModel characterData}) {
    return _CharacterProfileDataState(
      characterData: characterData,
    );
  }

// ignore: unused_element
  _CharacterProfileErrorState error() {
    return const _CharacterProfileErrorState();
  }
}

/// @nodoc
// ignore: unused_element
const $CharacterProfileState = _$CharacterProfileStateTearOff();

/// @nodoc
mixin _$CharacterProfileState {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult data(CharacterProfileModel characterData),
    @required TResult error(),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult data(CharacterProfileModel characterData),
    TResult error(),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_CharacterProfileLoadingState value),
    @required TResult data(_CharacterProfileDataState value),
    @required TResult error(_CharacterProfileErrorState value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_CharacterProfileLoadingState value),
    TResult data(_CharacterProfileDataState value),
    TResult error(_CharacterProfileErrorState value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $CharacterProfileStateCopyWith<$Res> {
  factory $CharacterProfileStateCopyWith(CharacterProfileState value,
          $Res Function(CharacterProfileState) then) =
      _$CharacterProfileStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$CharacterProfileStateCopyWithImpl<$Res>
    implements $CharacterProfileStateCopyWith<$Res> {
  _$CharacterProfileStateCopyWithImpl(this._value, this._then);

  final CharacterProfileState _value;
  // ignore: unused_field
  final $Res Function(CharacterProfileState) _then;
}

/// @nodoc
abstract class _$CharacterProfileLoadingStateCopyWith<$Res> {
  factory _$CharacterProfileLoadingStateCopyWith(
          _CharacterProfileLoadingState value,
          $Res Function(_CharacterProfileLoadingState) then) =
      __$CharacterProfileLoadingStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$CharacterProfileLoadingStateCopyWithImpl<$Res>
    extends _$CharacterProfileStateCopyWithImpl<$Res>
    implements _$CharacterProfileLoadingStateCopyWith<$Res> {
  __$CharacterProfileLoadingStateCopyWithImpl(
      _CharacterProfileLoadingState _value,
      $Res Function(_CharacterProfileLoadingState) _then)
      : super(_value, (v) => _then(v as _CharacterProfileLoadingState));

  @override
  _CharacterProfileLoadingState get _value =>
      super._value as _CharacterProfileLoadingState;
}

/// @nodoc
class _$_CharacterProfileLoadingState
    with DiagnosticableTreeMixin
    implements _CharacterProfileLoadingState {
  const _$_CharacterProfileLoadingState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterProfileState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterProfileState.loading'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CharacterProfileLoadingState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult data(CharacterProfileModel characterData),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult data(CharacterProfileModel characterData),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_CharacterProfileLoadingState value),
    @required TResult data(_CharacterProfileDataState value),
    @required TResult error(_CharacterProfileErrorState value),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_CharacterProfileLoadingState value),
    TResult data(_CharacterProfileDataState value),
    TResult error(_CharacterProfileErrorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _CharacterProfileLoadingState implements CharacterProfileState {
  const factory _CharacterProfileLoadingState() =
      _$_CharacterProfileLoadingState;
}

/// @nodoc
abstract class _$CharacterProfileDataStateCopyWith<$Res> {
  factory _$CharacterProfileDataStateCopyWith(_CharacterProfileDataState value,
          $Res Function(_CharacterProfileDataState) then) =
      __$CharacterProfileDataStateCopyWithImpl<$Res>;
  $Res call({CharacterProfileModel characterData});
}

/// @nodoc
class __$CharacterProfileDataStateCopyWithImpl<$Res>
    extends _$CharacterProfileStateCopyWithImpl<$Res>
    implements _$CharacterProfileDataStateCopyWith<$Res> {
  __$CharacterProfileDataStateCopyWithImpl(_CharacterProfileDataState _value,
      $Res Function(_CharacterProfileDataState) _then)
      : super(_value, (v) => _then(v as _CharacterProfileDataState));

  @override
  _CharacterProfileDataState get _value =>
      super._value as _CharacterProfileDataState;

  @override
  $Res call({
    Object characterData = freezed,
  }) {
    return _then(_CharacterProfileDataState(
      characterData: characterData == freezed
          ? _value.characterData
          : characterData as CharacterProfileModel,
    ));
  }
}

/// @nodoc
class _$_CharacterProfileDataState
    with DiagnosticableTreeMixin
    implements _CharacterProfileDataState {
  const _$_CharacterProfileDataState({@required this.characterData})
      : assert(characterData != null);

  @override
  final CharacterProfileModel characterData;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterProfileState.data(characterData: $characterData)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'CharacterProfileState.data'))
      ..add(DiagnosticsProperty('characterData', characterData));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _CharacterProfileDataState &&
            (identical(other.characterData, characterData) ||
                const DeepCollectionEquality()
                    .equals(other.characterData, characterData)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(characterData);

  @JsonKey(ignore: true)
  @override
  _$CharacterProfileDataStateCopyWith<_CharacterProfileDataState>
      get copyWith =>
          __$CharacterProfileDataStateCopyWithImpl<_CharacterProfileDataState>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult data(CharacterProfileModel characterData),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return data(characterData);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult data(CharacterProfileModel characterData),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (data != null) {
      return data(characterData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_CharacterProfileLoadingState value),
    @required TResult data(_CharacterProfileDataState value),
    @required TResult error(_CharacterProfileErrorState value),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return data(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_CharacterProfileLoadingState value),
    TResult data(_CharacterProfileDataState value),
    TResult error(_CharacterProfileErrorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (data != null) {
      return data(this);
    }
    return orElse();
  }
}

abstract class _CharacterProfileDataState implements CharacterProfileState {
  const factory _CharacterProfileDataState(
          {@required CharacterProfileModel characterData}) =
      _$_CharacterProfileDataState;

  CharacterProfileModel get characterData;
  @JsonKey(ignore: true)
  _$CharacterProfileDataStateCopyWith<_CharacterProfileDataState> get copyWith;
}

/// @nodoc
abstract class _$CharacterProfileErrorStateCopyWith<$Res> {
  factory _$CharacterProfileErrorStateCopyWith(
          _CharacterProfileErrorState value,
          $Res Function(_CharacterProfileErrorState) then) =
      __$CharacterProfileErrorStateCopyWithImpl<$Res>;
}

/// @nodoc
class __$CharacterProfileErrorStateCopyWithImpl<$Res>
    extends _$CharacterProfileStateCopyWithImpl<$Res>
    implements _$CharacterProfileErrorStateCopyWith<$Res> {
  __$CharacterProfileErrorStateCopyWithImpl(_CharacterProfileErrorState _value,
      $Res Function(_CharacterProfileErrorState) _then)
      : super(_value, (v) => _then(v as _CharacterProfileErrorState));

  @override
  _CharacterProfileErrorState get _value =>
      super._value as _CharacterProfileErrorState;
}

/// @nodoc
class _$_CharacterProfileErrorState
    with DiagnosticableTreeMixin
    implements _CharacterProfileErrorState {
  const _$_CharacterProfileErrorState();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'CharacterProfileState.error()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'CharacterProfileState.error'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _CharacterProfileErrorState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult loading(),
    @required TResult data(CharacterProfileModel characterData),
    @required TResult error(),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return error();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult loading(),
    TResult data(CharacterProfileModel characterData),
    TResult error(),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult loading(_CharacterProfileLoadingState value),
    @required TResult data(_CharacterProfileDataState value),
    @required TResult error(_CharacterProfileErrorState value),
  }) {
    assert(loading != null);
    assert(data != null);
    assert(error != null);
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult loading(_CharacterProfileLoadingState value),
    TResult data(_CharacterProfileDataState value),
    TResult error(_CharacterProfileErrorState value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _CharacterProfileErrorState implements CharacterProfileState {
  const factory _CharacterProfileErrorState() = _$_CharacterProfileErrorState;
}
